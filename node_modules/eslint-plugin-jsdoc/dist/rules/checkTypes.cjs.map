{"version":3,"file":"checkTypes.cjs","names":["_buildRejectOrPreferRuleDefinition","require","strictNativeTypes","checkNativeTypes","preferredTypes","typeNodeName","preferred","parentNode","invalidTypes","changedPreferred","strictNativeType","elements","length","left","type","value","toLowerCase","undefined","push","_default","exports","default","buildRejectOrPreferRuleDefinition","schema","additionalProperties","properties","exemptTagContexts","items","tag","types","oneOf","noDefaults","unifyParentAndChildTypeChecks","description","module"],"sources":["../../src/rules/checkTypes.js"],"sourcesContent":["import {\n  buildRejectOrPreferRuleDefinition,\n} from '../buildRejectOrPreferRuleDefinition.js';\n\nconst strictNativeTypes = [\n  'undefined',\n  'null',\n  'boolean',\n  'number',\n  'bigint',\n  'string',\n  'symbol',\n  'object',\n  'Array',\n  'Function',\n  'Date',\n  'RegExp',\n];\n\n/**\n * @callback CheckNativeTypes\n * Iterates strict types to see if any should be added to `invalidTypes` (and\n * the the relevant strict type returned as the new preferred type).\n * @param {import('../iterateJsdoc.js').PreferredTypes} preferredTypes\n * @param {string} typeNodeName\n * @param {string|undefined} preferred\n * @param {import('jsdoc-type-pratt-parser').NonRootResult|undefined} parentNode\n * @param {(string|false|undefined)[][]} invalidTypes\n * @returns {string|undefined} The `preferred` type string, optionally changed\n */\n\n/** @type {CheckNativeTypes} */\nconst checkNativeTypes = (preferredTypes, typeNodeName, preferred, parentNode, invalidTypes) => {\n  let changedPreferred = preferred;\n  for (const strictNativeType of strictNativeTypes) {\n    if (\n      strictNativeType === 'object' &&\n      (\n        // This is not set to remap with exact type match (e.g.,\n        //   `object: 'Object'`), so can ignore (including if circular)\n        !preferredTypes?.[typeNodeName] ||\n        // Although present on `preferredTypes` for remapping, this is a\n        //   parent object without a parent match (and not\n        //   `unifyParentAndChildTypeChecks`) and we don't want\n        //   `object<>` given TypeScript issue https://github.com/microsoft/TypeScript/issues/20555\n        /**\n         * @type {import('jsdoc-type-pratt-parser').GenericResult}\n         */\n        (\n          parentNode\n        )?.elements?.length && (\n        /**\n         * @type {import('jsdoc-type-pratt-parser').GenericResult}\n         */\n          (\n            parentNode\n          )?.left?.type === 'JsdocTypeName' &&\n          /**\n           * @type {import('jsdoc-type-pratt-parser').GenericResult}\n           */\n          (parentNode)?.left?.value === 'Object'\n        )\n      )\n    ) {\n      continue;\n    }\n\n    if (strictNativeType !== typeNodeName &&\n      strictNativeType.toLowerCase() === typeNodeName.toLowerCase() &&\n\n      // Don't report if user has own map for a strict native type\n      (!preferredTypes || preferredTypes?.[strictNativeType] === undefined)\n    ) {\n      changedPreferred = strictNativeType;\n      invalidTypes.push([\n        typeNodeName, changedPreferred,\n      ]);\n      break;\n    }\n  }\n\n  return changedPreferred;\n};\n\nexport default buildRejectOrPreferRuleDefinition({\n  checkNativeTypes,\n  schema: [\n    {\n      additionalProperties: false,\n      properties: {\n        exemptTagContexts: {\n          items: {\n            additionalProperties: false,\n            properties: {\n              tag: {\n                type: 'string',\n              },\n              types: {\n                oneOf: [\n                  {\n                    type: 'boolean',\n                  },\n                  {\n                    items: {\n                      type: 'string',\n                    },\n                    type: 'array',\n                  },\n                ],\n              },\n            },\n            type: 'object',\n          },\n          type: 'array',\n        },\n        noDefaults: {\n          type: 'boolean',\n        },\n        unifyParentAndChildTypeChecks: {\n          description: '@deprecated Use the `preferredTypes[preferredType]` setting of the same name instead',\n          type: 'boolean',\n        },\n      },\n      type: 'object',\n    },\n  ],\n});\n"],"mappings":";;;;;;AAAA,IAAAA,kCAAA,GAAAC,OAAA;AAIA,MAAMC,iBAAiB,GAAG,CACxB,WAAW,EACX,MAAM,EACN,SAAS,EACT,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,OAAO,EACP,UAAU,EACV,MAAM,EACN,QAAQ,CACT;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMC,gBAAgB,GAAGA,CAACC,cAAc,EAAEC,YAAY,EAAEC,SAAS,EAAEC,UAAU,EAAEC,YAAY,KAAK;EAC9F,IAAIC,gBAAgB,GAAGH,SAAS;EAChC,KAAK,MAAMI,gBAAgB,IAAIR,iBAAiB,EAAE;IAChD,IACEQ,gBAAgB,KAAK,QAAQ;IAE3B;IACA;IACA,CAACN,cAAc,GAAGC,YAAY,CAAC;IAC/B;IACA;IACA;IACA;IACA;AACR;AACA;IAEUE,UAAU,EACTI,QAAQ,EAAEC,MAAM;IACnB;AACR;AACA;IAEYL,UAAU,EACTM,IAAI,EAAEC,IAAI,KAAK,eAAe;IACjC;AACV;AACA;IACWP,UAAU,EAAGM,IAAI,EAAEE,KAAK,KAAK,QAAQ,CACvC,CACF,EACD;MACA;IACF;IAEA,IAAIL,gBAAgB,KAAKL,YAAY,IACnCK,gBAAgB,CAACM,WAAW,CAAC,CAAC,KAAKX,YAAY,CAACW,WAAW,CAAC,CAAC;IAE7D;IACC,CAACZ,cAAc,IAAIA,cAAc,GAAGM,gBAAgB,CAAC,KAAKO,SAAS,CAAC,EACrE;MACAR,gBAAgB,GAAGC,gBAAgB;MACnCF,YAAY,CAACU,IAAI,CAAC,CAChBb,YAAY,EAAEI,gBAAgB,CAC/B,CAAC;MACF;IACF;EACF;EAEA,OAAOA,gBAAgB;AACzB,CAAC;AAAC,IAAAU,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEa,IAAAC,oEAAiC,EAAC;EAC/CnB,gBAAgB;EAChBoB,MAAM,EAAE,CACN;IACEC,oBAAoB,EAAE,KAAK;IAC3BC,UAAU,EAAE;MACVC,iBAAiB,EAAE;QACjBC,KAAK,EAAE;UACLH,oBAAoB,EAAE,KAAK;UAC3BC,UAAU,EAAE;YACVG,GAAG,EAAE;cACHd,IAAI,EAAE;YACR,CAAC;YACDe,KAAK,EAAE;cACLC,KAAK,EAAE,CACL;gBACEhB,IAAI,EAAE;cACR,CAAC,EACD;gBACEa,KAAK,EAAE;kBACLb,IAAI,EAAE;gBACR,CAAC;gBACDA,IAAI,EAAE;cACR,CAAC;YAEL;UACF,CAAC;UACDA,IAAI,EAAE;QACR,CAAC;QACDA,IAAI,EAAE;MACR,CAAC;MACDiB,UAAU,EAAE;QACVjB,IAAI,EAAE;MACR,CAAC;MACDkB,6BAA6B,EAAE;QAC7BC,WAAW,EAAE,sFAAsF;QACnGnB,IAAI,EAAE;MACR;IACF,CAAC;IACDA,IAAI,EAAE;EACR,CAAC;AAEL,CAAC,CAAC;AAAAoB,MAAA,CAAAd,OAAA,GAAAA,OAAA,CAAAC,OAAA","ignoreList":[]}